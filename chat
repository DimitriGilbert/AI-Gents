#!/bin/bash
# @parseArger-begin
# @parseArger-help "I send an SOS to the world" --option "help" --short-option "h"
# @parseArger-verbose --option "verbose" --level "0" --quiet-option "quiet"
_has_colors=0
if [ -t 1 ]; then # Check if stdout is a terminal
    ncolors=$(tput colors 2>/dev/null)
    if [ -n "$ncolors" ] && [ "$ncolors" -ge 8 ]; then
        _has_colors=1
    fi
fi
# @parseArger-declarations
# @parseArger pos message "message to the AI"
# @parseArger opt api "api url"
# @parseArger opt api-key "api key"
# @parseArger opt model "model name"
# @parseArger opt system "system prompt"
# @parseArger opt ai-name "AI"
# @parseArger opt username "your name" --default-value "You"
# @parseArger opt log-file "log file for the chat" --default-value "$(date '+%Y-%m-%d-%H-%M-%S.md' )"
# @parseArger opt agent "agent file to load"
# @parseArger opt agent-task "agent specific task to perfrom"
# @parseArger flag log-user "log user input" --on
# @parseArger flag log-ai "log ai output" --on
# @parseArger-declarations-end

# @parseArger-utils
_helpHasBeenPrinted=1
_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
# @parseArger-utils-end

# @parseArger-parsing

__cli_arg_count=$#

die() {
    local _ret=1
    if [[ -n "$2" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
        _ret="$2"
    fi
    test "${_PRINT_HELP:-no}" = yes && print_help >&2
    log "$1" -3 >&2
    exit "${_ret}"
}

begins_with_short_option() {
    local first_option all_short_options=''
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# POSITIONALS ARGUMENTS
_positionals=()
_optional_positionals=()
_arg_message=""
# OPTIONALS ARGUMENTS
_arg_api=
_arg_api_key=
_arg_model=
_arg_system=
_arg_ai_name=
_arg_username="You"
_arg_log_file="$(date '+%Y-%m-%d-%H-%M-%S.md')"
_arg_agent=
_arg_agent_task=
# FLAGS
_arg_log_user="on"
_arg_log_ai="on"
# NESTED
_verbose_level="0"

print_help() {
    _triggerSCHelp=1

    if [[ "$_helpHasBeenPrinted" == "1" ]]; then
        _helpHasBeenPrinted=0
        echo -e "I send an SOS to the world:"
        echo -e "	message: message to the AI"
        echo -e "	--api <api>: api url"
        echo -e "	--api-key <api-key>: api key"
        echo -e "	--model <model>: model name"
        echo -e "	--system <system>: system prompt"
        echo -e "	--ai-name <ai-name>: AI"
        echo -e "	--username <username>: your name [default: ' You ']"
        echo -e "	--log-file <log-file>: log file for the chat [default: ' $(date '+%Y-%m-%d-%H-%M-%S.md') ']"
        echo -e "	--agent <agent>: agent file to load"
        echo -e "	--agent-task <agent-task>: agent specific task to perfrom"
        echo -e "	--log-user|--no-log-user: log user input, on by default (use --no-log-user to turn it off)"
        echo -e "	--log-ai|--no-log-ai: log ai output, on by default (use --no-log-ai to turn it off)"
        echo -e "Usage :
	$0 <message> [--api <value>] [--api-key <value>] [--model <value>] [--system <value>] [--ai-name <value>] [--username <value>] [--log-file <value>] [--agent <value>] [--agent-task <value>] [--[no-]log-user] [--[no-]log-ai]"
    fi

}

log() {
    local _arg_msg="${1}"
    local _arg_level="${2:-0}"
    if [ "${_arg_level}" -le "${_verbose_level}" ]; then
        case "$_arg_level" in
        -3)
            _arg_COLOR="\033[0;31m"
            ;;
        -2)
            _arg_COLOR="\033[0;33m"
            ;;
        -1)
            _arg_COLOR="\033[1;33m"
            ;;
        1)
            _arg_COLOR="\033[0;32m"
            ;;
        2)
            _arg_COLOR="\033[1;36m"
            ;;
        3)
            _arg_COLOR="\033[0;36m"
            ;;
        *)
            _arg_COLOR="\033[0m"
            ;;
        esac
        if [ "${_has_colors}" == "1" ]; then
            echo -e "${_arg_COLOR}${_arg_msg}\033[0m"
        else
            echo "${_arg_msg}"
        fi
    fi
}

parse_commandline() {
    _positionals_count=0
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --api)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_api="$2"
            shift
            ;;
        --api=*)
            _arg_api="${_key##--api=}"
            ;;

        --api-key)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_api_key="$2"
            shift
            ;;
        --api-key=*)
            _arg_api_key="${_key##--api-key=}"
            ;;

        --model)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_model="$2"
            shift
            ;;
        --model=*)
            _arg_model="${_key##--model=}"
            ;;

        --system)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_system="$2"
            shift
            ;;
        --system=*)
            _arg_system="${_key##--system=}"
            ;;

        --ai-name)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_ai_name="$2"
            shift
            ;;
        --ai-name=*)
            _arg_ai_name="${_key##--ai-name=}"
            ;;

        --username)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_username="$2"
            shift
            ;;
        --username=*)
            _arg_username="${_key##--username=}"
            ;;

        --log-file)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_log_file="$2"
            shift
            ;;
        --log-file=*)
            _arg_log_file="${_key##--log-file=}"
            ;;

        --agent)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_agent="$2"
            shift
            ;;
        --agent=*)
            _arg_agent="${_key##--agent=}"
            ;;

        --agent-task)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_agent_task="$2"
            shift
            ;;
        --agent-task=*)
            _arg_agent_task="${_key##--agent-task=}"
            ;;

        --log-user)
            _arg_log_user="on"
            ;;
        --no-log-user)
            _arg_log_user="off"
            ;;
        --log-ai)
            _arg_log_ai="on"
            ;;
        --no-log-ai)
            _arg_log_ai="off"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        --verbose)
            if [ $# -lt 2 ]; then
                _verbose_level="$((_verbose_level + 1))"
            else
                _verbose_level="$2"
                shift
            fi
            ;;
        --quiet)
            if [ $# -lt 2 ]; then
                _verbose_level="$((_verbose_level - 1))"
            else
                _verbose_level="-$2"
                shift
            fi
            ;;

        *)
            _last_positional="$1"
            _positionals+=("$_last_positional")
            _positionals_count=$((_positionals_count + 1))
            ;;
        esac
        shift
    done
}

handle_passed_args_count() {
    local _required_args_string="message"
    if [ "${_positionals_count}" -gt 1 ] && [ "$_helpHasBeenPrinted" == "1" ]; then
        _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\n\t${_positionals[*]}" 1
    fi
    if [ "${_positionals_count}" -lt 1 ] && [ "$_helpHasBeenPrinted" == "1" ]; then
        _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.
	${_positionals[*]}" 1
    fi
}

assign_positional_args() {
    local _positional_name _shift_for=$1
    _positional_names="_arg_message "
    shift "$_shift_for"
    for _positional_name in ${_positional_names}; do
        test $# -gt 0 || break
        eval "if [ \"\$_one_of${_positional_name}\" != \"\" ];then [[ \"\${_one_of${_positional_name}[*]}\" =~ \"\${1}\" ]];fi" || die "${_positional_name} must be one of: $(eval "echo \"\${_one_of${_positional_name}[*]}\"")" 1
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an ParseArger bug." 1
        shift
    done
}

print_debug() {
    print_help
    # shellcheck disable=SC2145
    echo "DEBUG: $0 $@"

    echo -e "	message: ${_arg_message}"
    echo -e "	api: ${_arg_api}"
    echo -e "	api-key: ${_arg_api_key}"
    echo -e "	model: ${_arg_model}"
    echo -e "	system: ${_arg_system}"
    echo -e "	ai-name: ${_arg_ai_name}"
    echo -e "	username: ${_arg_username}"
    echo -e "	log-file: ${_arg_log_file}"
    echo -e "	agent: ${_arg_agent}"
    echo -e "	agent-task: ${_arg_agent_task}"
    echo -e "	log-user: ${_arg_log_user}"
    echo -e "	log-ai: ${_arg_log_ai}"

}

on_interrupt() {
    die Process aborted! 130
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"
trap on_interrupt INT

# @parseArger-parsing-end
# print_debug "$@"
# @parseArger-end

_AGENT_CONFIG=""



# Function to parse tool documentation from the agent config
parse_tool_docs() {
    if [[ "$_AGENT_CONFIG" != "" ]]; then
        local tool_docs=""
        
        # Get number of tools from functions array
        local tool_count="$(echo "$_AGENT_CONFIG" | yq '.tools.functions | length' -)"
        
        # Iterate through tools by index
        for ((i=0; i<tool_count; i++)); do
            # Extract tool info using proper array indexing
            local name="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].name" -)"
            local desc="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].description" -)"
            local returns="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].returns.description" -)"
            
            tool_docs+="### ${name}\n${desc}\n"
            
            # Get parameters from properties
            local params="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].parameters.properties | keys | .[]" -)"
            local required="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].parameters.required | .[]" -)"
            
            # Process each parameter
            while IFS= read -r param_name; do
                [[ "$param_name" == "null" ]] && continue
                
                local param_type="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].parameters.properties.[\"${param_name}\"].type" -)"
                local param_desc="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].parameters.properties.[\"${param_name}\"].description" -)"
                local param_default="$(echo "$_AGENT_CONFIG" | yq ".tools.functions[$i].parameters.properties.[\"${param_name}\"].default" -)"
                
                local req_flag="[opt]"
                [[ "$required" =~ $param_name ]] && req_flag="[req]"
                
                tool_docs+="* ${param_name} (${param_type}) ${req_flag} ${param_desc}"
                [[ "$param_default" != "null" ]] && tool_docs+=" (default: ${param_default})"
                tool_docs+="\n"
            done < <(printf '%s\n' "$params")
            
            [[ "$returns" != "null" ]] && tool_docs+="* Returns: ${returns}\n"
            tool_docs+="\n"
        done
        
        # Return the docs as plain text
        printf '%b' "$tool_docs"
    fi
}

# Function to load agent configuration
load_agent_config() {
    local agent_file="$1"
    if [[ ! -f "$agent_file" ]]; then
        die "Agent file not found: $agent_file" 1
    fi
    _AGENT_CONFIG="$(cat "$agent_file")"

    # Check if yq is installed
    if ! command -v yq &>/dev/null; then
        die "yq is required to parse YAML files. Please install it first." 1
    fi

    # Load configuration
    if [[ "$_arg_model" = "" ]]; then
        _arg_model="$(echo "$_AGENT_CONFIG" | yq -r '.model.name')"
    fi
    _arg_system="$(echo "$_AGENT_CONFIG" | yq -r '.system.prompt')"
    _arg_ai_name="$(echo "$_AGENT_CONFIG" | yq -r '.name')"

    # Set API based on provider if not explicitly set
    if [[ -z "$_arg_api" ]]; then
        local provider
        provider="$(yq '.model.provider' "$agent_file" </dev/null)"
        case "$provider" in
        "openai")
            _arg_api="https://api.openai.com/v1/chat/completions"
            ;;
        "lmstudio")
            _arg_api="http://localhost:1234/v1/chat/completions"
            ;;
        *)
            die "Unsupported provider: $provider" 1
            ;;
        esac
    fi

    # Load memory window setting
    local memory_window
    memory_window="$(yq '.settings.memory_window' "$agent_file" </dev/null)"
    if [[ "$memory_window" != "null" ]]; then
        export MEMORY_WINDOW="$memory_window"
    fi

    # Build system prompt using jq to handle escaping
    local prompt_parts=()
    prompt_parts+=("$_arg_system")
    
    # Add system prompt from agent if exists
    SYSTEM_PROMPT="$(yq '.system.prompt' "$agent_file" </dev/null)"
    if [ "$SYSTEM_PROMPT" != "" ]; then
        prompt_parts+=("$SYSTEM_PROMPT")
    fi
    
    # Add agent task if specified
    if [ "$_arg_agent_task" != "" ]; then
        prompt_parts+=("$_arg_agent_task")
    fi
    
    # Add tool documentation if available
    local tool_docs
    tool_docs="$(parse_tool_docs </dev/null)"
    if [ "$tool_docs" != "" ]; then
        TOOL_PROMPT="$(yq -r '.system.toolPrompt' "$agent_file" </dev/null)"
        if [ "$TOOL_PROMPT" != "" ]; then
            prompt_parts+=("$TOOL_PROMPT")
        else
            prompt_parts+=("Available tools:")
        fi
        prompt_parts+=("$tool_docs")
    fi

    # Combine all parts with newlines, no escaping needed
    _arg_system="$(printf '%s\n' "${prompt_parts[@]}" </dev/null)"

    # echo -e "$_arg_system"
    # echo -e "############################################################\n\n"
}

# Configuration
API_KEY="${_arg_api_key}" # Replace with your actual API key

# Load agent configuration if specified
if [[ -n "$_arg_agent" ]]; then
    load_agent_config "$_arg_agent"
fi

# Set default API URL if not set
if [[ ! "$_arg_api" =~ ^https?:// ]] && [[ ! "$_arg_api" =~ ^http:// ]]; then
    _arg_api="http://$_arg_api"
fi

# Initialize conversation history and system prompt
CONVERSATION_HISTORY=()
SYSTEM_PROMPT=""
last_message=""

# Function to log messages to the file
log_to_file() {
    local role="$1"
    local content="$2"
    local timestamp
    timestamp="$(date '+%Y-%m-%d %H:%M:%S' </dev/null)"

    # Create directory if it doesn't exist
    local logdir
    logdir="$(dirname "${_arg_log_file}" </dev/null)"
    mkdir -p "${logdir}"

    # Append message to log file in markdown format
    echo -e "\n### ${role} (${timestamp})\n\n${content}\n" >> "${_arg_log_file}"
}

# Function to parse tool calls from the message
parse_tool_calls() {
    local message="$1"
    # Look for tool calls in the format: {"tool_calls":[{"type":"function","function":{"name":"...","arguments":{...}}}]}
    if [[ "$message" =~ \"tool_calls\" ]]; then
        # Extract function calls using sed
        echo "$message" | sed -n 's/.*"function":\([^}]*}\).*/\1/p'
    fi
}

# Function to execute tools
execute_agent_tool() {
    local tool_name="$1"
    local arguments="$2"
    # Check if command exists and execute
    if command -v "${tool_name}" >/dev/null 2>&1; then
        # Build the command array
        local cmd=()
        
        # Parse arguments using yq with here-strings
        while IFS= read -r line; do
            key="$(yq '.key' <<<"$line")"
            value="$(yq '.value' <<<"$line")"
            cmd+=("--${key}" "${value}")
        done < <(yq -o=json '. | to_entries | .[]' <<<"$arguments")
        "${cmd[@]}"
        return $?
    else
        log "Error: Tool '${tool_name}' not found" -1
        return 1
    fi
}

# Function to send a message to the LLM API and stream the response
send_message() {
    local user_message="$1"
    local system_message="$2"
    local tmp_response
    local tmp_payload
    local full_response
    local content
    local line
    
    tmp_response="$(TMPDIR="${TMPDIR:-/tmp}" mktemp </dev/null)" || return 1
    tmp_response_text="$(TMPDIR="${TMPDIR:-/tmp}" mktemp </dev/null)" || return 1
    tmp_payload="$(TMPDIR="${TMPDIR:-/tmp}" mktemp </dev/null)" || return 1

    # Create the JSON payload using jq to handle all escaping
    if [ "$system_message" != "" ] && [ "$user_message" != "" ]; then
        jq -R -s '.' <<<"$system_message" > "$tmp_payload.system"
        jq -R -s '.' <<<"$user_message" > "$tmp_payload.user"
        printf '{
            "model": "%s",
            "messages": [
                {"role": "system", "content": %s},
                {"role": "user", "content": %s}
            ],
            "stream": true
        }' "${_arg_model,,}" "$(cat "$tmp_payload.system" </dev/null)" "$(cat "$tmp_payload.user" </dev/null)" > "$tmp_payload"
        rm -f "$tmp_payload.system" "$tmp_payload.user"
    fi

    # Send the request and stream response
    local curl_cmd=(curl -N -s -X POST "$_arg_api"
        -H "Content-Type: application/json"
        -d @"$tmp_payload")
    if [ "$API_KEY" != "" ]; then
        curl_cmd+=(-H "Authorization: Bearer $API_KEY")
    fi

    # die "${curl_cmd[*]}";
    # Execute curl and process response
    "${curl_cmd[@]}" 2>/dev/null | while IFS= read -r line || [ -n "$line" ]; do
        # echo "$line"
        if [ "${line:0:5}" = "data:" ]; then
            line="${line#data: }"
            if [ "$line" != "" ] && [ "$line" != "[DONE]" ]; then
                printf '%s\n' "$line" >> "$tmp_response"
                # Check for error response
                if [[ "$line" =~ \"error\":\{.*\"message\":\"([^\"]*)\" ]]; then
                    error_msg="${BASH_REMATCH[1]}"
                    die "API Error: ${error_msg}" -2
                fi
                # Extract content directly between "content":"..." without jq
                if [[ "$line" =~ \"content\":\"([^\"]*)\" ]]; then
                    content="${BASH_REMATCH[1]}"
                    printf '%b' "${content//\\\"/\"}" >> "$tmp_response_text";
                    printf '%b' "${content//\\\"/\"}";
                fi
            fi
        elif [[ "$line" =~ \"error\":\{.*\"message\":\"([^\"]*)\" ]]; then
            # Handle non-streaming error responses
            error_msg="${BASH_REMATCH[1]}"
            die "API Error: ${error_msg}" -2
        fi
    done
    printf '\n'

    # Get the full response and update conversation history
    if [ -f "$tmp_response" ]; then
        full_response="$(cat "$tmp_response")"
        if [ "$full_response" != "" ]; then
            # Add messages to history with proper escaping
            local user_json
            local assistant_json
            user_json="$(printf '{"role":"user","content":%s}' "$(printf '%s' "$user_message" | jq -R -s '.')")"
            assistant_json="$(printf '{"role":"assistant","content":%s}' "$(printf '%s' "$full_response" | jq -R -s '.')")"
            
            CONVERSATION_HISTORY+=("$user_json")
            CONVERSATION_HISTORY+=("$assistant_json")

            # Log AI response if enabled
            if [ "$_arg_log_ai" = "on" ]; then
                log_to_file "$_arg_ai_name" "$(cat "$tmp_response_text")"
            fi

            # Trim history if memory window is set
            if [ "$MEMORY_WINDOW" != "" ]; then
                local window_size=$((MEMORY_WINDOW * 2))
                if [ ${#CONVERSATION_HISTORY[@]} -gt $window_size ]; then
                    CONVERSATION_HISTORY=("${CONVERSATION_HISTORY[@]: -$window_size}")
                fi
            fi
        fi
    fi

    # Export last message
    if [ -f "$tmp_response_text" ]; then
        last_message="$(cat "$tmp_response_text")"
        export last_message
    fi
    rm -f "$tmp_response" "$tmp_payload" "$tmp_response_text"
}

# Main loop for user interaction
echo "Welcome to the LLM Chat! Type '/bye' to quit."
if [[ "$_arg_message" != "" ]]; then
    if [[ "$_arg_log_user" == "on" ]]; then
        log_to_file "$_arg_username" "$_arg_message"
    fi
    echo -n "$_arg_ai_name: "
    # Store system prompt if provided via command line
    if [[ -n "$_arg_system" ]]; then
        SYSTEM_PROMPT="$_arg_system"
    fi
    send_message "$_arg_message" "$SYSTEM_PROMPT"
fi

while true; do
    echo
    user_input="$(rlwrap -S "${_arg_username}: " bash -c 'read -r line && echo "${line}"')"
    if [[ "$user_input" == "/bye" ]]; then
        echo "Goodbye!"
        break
    elif [[ "$user_input" =~ ^/task ]] && [ "$_AGENT_CONFIG" != "" ]; then
        task_name="$(echo "$user_input" | cut -d' ' -f2-)"
        task="$(echo "$_AGENT_CONFIG" | yq ".tasks.$task_name")"
        if [ "$task" = "" ]; then
            echo "Task not found: $task_name"
        else
            task_prompt="$(echo "$task" | yq ".prompt")"
            message_after_task="$(echo "$user_input" | cut -d' ' -f3-)"
            if [ "$message_after_task" != "" ]; then
                task_prompt="$task_prompt$message_after_task"
            fi
            send_message "$task_prompt" "$SYSTEM_PROMPT"
        fi
        continue
    fi
    if [[ "$_arg_log_user" == "on" ]]; then
        log_to_file "$_arg_username" "$user_input"
    fi
    echo -n "$_arg_ai_name: "
    send_message "$user_input" "$SYSTEM_PROMPT"
done
