#!/bin/bash
#
# Core library for AI-Gents
# Logging, caching, lazy loading, and common utilities
#

# Logging levels:
# 2 = DEBUG (verbose)
# 1 = INFO
# 0 = NORMAL
# -1 = WARNING
# -2 = ERROR
# -3 = CRITICAL

log() {
    local message="$1"
    local level="${2:-0}"
    local prefix=""
    
    # Check if we should log based on verbose level
    if [[ "${level}" -gt "${_verbose_level:-0}" ]]; then
        return 0
    fi
    
    # Set prefix based on level
    case "$level" in
        2) prefix="[DEBUG] " ;;
        1) prefix="[INFO] " ;;
        -1) prefix="[WARN] " ;;
        -2) prefix="[ERROR] " ;;
        -3) prefix="[CRITICAL] " ;;
    esac
    
    echo "${prefix}${message}"
}

# Get agent file path
# Usage: get_agent_file <agent_name>
get_agent_file() {
    local agent_name="$1"
    local agents_dir="${AI_USER_CONFIG_DIR}/agents"
    echo "${agents_dir}/${agent_name}.yml"
}

# Check if agent exists
# Usage: agent_exists <agent_name>
agent_exists() {
    local agent_name="$1"
    local agent_file
    agent_file="$(get_agent_file "$agent_name")"
    [[ -f "$agent_file" ]]
}

# Simple cache for expensive operations
# Usage: cache_set <key> <value>
declare -A _CACHE
cache_set() {
    local key="$1"
    local value="$2"
    _CACHE["$key"]="$value"
}

# Usage: cache_get <key>
cache_get() {
    local key="$1"
    echo "${_CACHE[$key]:-}"
}

# Usage: cache_has <key>
cache_has() {
    local key="$1"
    [[ -n "${_CACHE[$key]:-}" ]]
}

# Usage: cache_clear
cache_clear() {
    _CACHE=()
}

# Lazy loading wrapper with TTL support
# Usage: lazy_load <cache_key> <loader_function> [ttl_seconds] [args...]
lazy_load() {
    local cache_key="$1"
    local loader="$2"
    local ttl="${3:-0}"
    shift 3
    
    # Check if cached and not expired
    if cache_has "$cache_key"; then
        if [[ $ttl -gt 0 ]]; then
            local cache_time
            cache_time="${_CACHE_TIME[$cache_key]:-0}"
            local current_time
            current_time=$(date +%s)
            if [[ $((current_time - cache_time)) -le $ttl ]]; then
                cache_get "$cache_key"
                return 0
            fi
        else
            cache_get "$cache_key"
            return 0
        fi
    fi
    
    local result
    result="$($loader "$@")"
    cache_set "$cache_key" "$result"
    
    # Store cache timestamp
    if [[ $ttl -gt 0 ]]; then
        _CACHE_TIME[$cache_key]=$(date +%s)
    fi
    
    echo "$result"
}

# Lazy load agent configuration
# Usage: lazy_load_agent <agent_name>
lazy_load_agent() {
    local agent_name="$1"
    local cache_key="agent:${agent_name}"
    
    lazy_load "$cache_key" "get_agent_file" 300 "$agent_name"
}

# Lazy load provider
# Usage: lazy_load_provider <provider_name>
lazy_load_provider() {
    local provider_name="$1"
    local cache_key="provider:${provider_name}"
    
    lazy_load "$cache_key" "_load_provider_cached" 0 "$provider_name"
}

# Internal: load provider and return success
_load_provider_cached() {
    local provider_name="$1"
    if provider_load "$provider_name" 2>/dev/null; then
        echo "loaded"
    else
        echo "failed"
    fi
}

# Clear expired cache entries
cache_clear_expired() {
    local current_time
    current_time=$(date +%s)
    
    for key in "${_CACHE_TIME[@]}"; do
        local cache_time="${_CACHE_TIME[$key]}"
        # Default TTL of 5 minutes if not specified
        if [[ $((current_time - cache_time)) -gt 300 ]]; then
            unset "_CACHE[$key]"
            unset "_CACHE_TIME[$key]"
        fi
    done
}

# Parse command from user input
# Usage: parse_command <command_string>
# Returns: array of command parts via nameref
parse_command() {
    local cmd_str="$1"
    local -n target_arr="$2"
    
    # Simple parsing - split on whitespace
    read -ra target_arr <<< "$cmd_str"
}

# Die function (already in parseArger-generated code, but for non-parseArger files)
die() {
    local _ret=1
    if [[ -n "${2:-}" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
        _ret="$2"
    fi
    log "$1" -3 >&2
    exit "${_ret}"
}

# =============================================================================
# DEFAULT SYSTEM PROMPT
# =============================================================================

# Build default system prompt with program info and capabilities
# This is ALWAYS prepended to any user-provided system prompt
# Usage: build_default_system_prompt
build_default_system_prompt() {
    local date_str
    date_str=$(date +"%Y-%m-%d %H:%M:%S")
    
    cat <<EOF
You are AI-Gents, a bash-based AI CLI interface.
Date: $date_str

CAPABILITIES:
- Execute bash commands using the 'bash' tool
- Use other available tools to help complete tasks
- When you need to run a command, call the bash tool with the command string

You have access to a bash tool that can execute any shell command.
EOF
}

# Build full system prompt by combining default + user prompt
# Usage: build_full_system_prompt [user_system_prompt]
build_full_system_prompt() {
    local user_system="${1:-}"
    local default_prompt
    default_prompt=$(build_default_system_prompt)
    
    if [[ -n "$user_system" ]]; then
        echo -e "${default_prompt}\n\nUSER INSTRUCTIONS:\n${user_system}"
    else
        echo "$default_prompt"
    fi
}
