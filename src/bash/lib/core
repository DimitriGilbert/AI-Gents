#!/bin/bash
#
# Core library for AI-Gents
# Logging, caching, lazy loading, and common utilities
#

# Logging levels:
# 2 = DEBUG (verbose)
# 1 = INFO
# 0 = NORMAL
# -1 = WARNING
# -2 = ERROR
# -3 = CRITICAL

log() {
    local message="$1"
    local level="${2:-0}"
    local prefix=""
    
    # Check if we should log based on verbose level
    if [[ "${level}" -gt "${_verbose_level:-0}" ]]; then
        return 0
    fi
    
    # Set prefix based on level
    case "$level" in
        2) prefix="[DEBUG] " ;;
        1) prefix="[INFO] " ;;
        -1) prefix="[WARN] " ;;
        -2) prefix="[ERROR] " ;;
        -3) prefix="[CRITICAL] " ;;
    esac
    
    echo "${prefix}${message}"
}

# Get agent file path
# Usage: get_agent_file <agent_name>
get_agent_file() {
    local agent_name="$1"
    local agents_dir="${AI_USER_CONFIG_DIR}/agents"
    echo "${agents_dir}/${agent_name}.yml"
}

# Check if agent exists
# Usage: agent_exists <agent_name>
agent_exists() {
    local agent_name="$1"
    local agent_file
    agent_file="$(get_agent_file "$agent_name")"
    [[ -f "$agent_file" ]]
}

# Simple cache for expensive operations
# Usage: cache_set <key> <value>
declare -A _CACHE
cache_set() {
    local key="$1"
    local value="$2"
    _CACHE["$key"]="$value"
}

# Usage: cache_get <key>
cache_get() {
    local key="$1"
    echo "${_CACHE[$key]:-}"
}

# Usage: cache_has <key>
cache_has() {
    local key="$1"
    [[ -n "${_CACHE[$key]:-}" ]]
}

# Usage: cache_clear
cache_clear() {
    _CACHE=()
}

# Lazy loading wrapper
# Usage: lazy_load <cache_key> <loader_function> [args...]
lazy_load() {
    local cache_key="$1"
    local loader="$2"
    shift 2
    
    if cache_has "$cache_key"; then
        cache_get "$cache_key"
        return 0
    fi
    
    local result
    result="$($loader "$@")"
    cache_set "$cache_key" "$result"
    echo "$result"
}

# Parse command from user input
# Usage: parse_command <command_string>
# Returns: array of command parts via nameref
parse_command() {
    local cmd_str="$1"
    local -n target_arr="$2"
    
    # Simple parsing - split on whitespace
    read -ra target_arr <<< "$cmd_str"
}

# Die function (already in parseArger-generated code, but for non-parseArger files)
die() {
    local _ret=1
    if [[ -n "${2:-}" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
        _ret="$2"
    fi
    log "$1" -3 >&2
    exit "${_ret}"
}
