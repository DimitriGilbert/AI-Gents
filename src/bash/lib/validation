#!/bin/bash
#
# Validation library for AI-Gents
# Input validation functions for LLM parameters and user inputs
# All functions return 0 (valid) or 1 (invalid)
#

# LLM Parameter Validation
# Temperature: 0 to 2
validate_temperature() {
    local val="$1"
    [[ "$val" =~ ^[0-9]+(\.[0-9]+)?$ ]] || return 1
    # Use bc for floating point comparison
    if (( $(echo "$val < 0" | bc -l) )) || (( $(echo "$val > 2" | bc -l) )); then
        return 1
    fi
    return 0
}

# Top_p: 0 to 1
validate_top_p() {
    local val="$1"
    [[ "$val" =~ ^[0-9]+(\.[0-9]+)?$ ]] || return 1
    if (( $(echo "$val < 0" | bc -l) )) || (( $(echo "$val > 1" | bc -l) )); then
        return 1
    fi
    return 0
}

# Max tokens: positive integer, reasonable upper bound
validate_max_tokens() {
    local val="$1"
    [[ "$val" =~ ^[0-9]+$ ]] || return 1
    (( val > 0 && val <= 100000 )) || return 1
    return 0
}

# Frequency penalty: -2 to 2
validate_frequency_penalty() {
    local val="$1"
    [[ "$val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] || return 1
    if (( $(echo "$val < -2" | bc -l) )) || (( $(echo "$val > 2" | bc -l) )); then
        return 1
    fi
    return 0
}

# Presence penalty: -2 to 2
validate_presence_penalty() {
    local val="$1"
    [[ "$val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] || return 1
    if (( $(echo "$val < -2" | bc -l) )) || (( $(echo "$val > 2" | bc -l) )); then
        return 1
    fi
    return 0
}

# Seed: non-negative integer
validate_seed() {
    local val="$1"
    [[ "$val" =~ ^[0-9]+$ ]] || return 1
    return 0
}

# Validate provider against available provider plugins
validate_provider() {
    local val="$1"
    local provider_file="${_SCRIPT_DIR}/lib/providers/${val}"
    [[ -f "$provider_file" ]] || return 1
    return 0
}

# Generic validator dispatcher
# Usage: validate_param <param_name> <value>
validate_param() {
    local param="$1"
    local value="$2"
    
    case "$param" in
        temperature) validate_temperature "$value" ;;
        top_p) validate_top_p "$value" ;;
        max_tokens) validate_max_tokens "$value" ;;
        frequency_penalty) validate_frequency_penalty "$value" ;;
        presence_penalty) validate_presence_penalty "$value" ;;
        seed) validate_seed "$value" ;;
        provider) validate_provider "$value" ;;
        *) return 0 ;;  # Unknown params pass through
    esac
}

# Validate all LLM parameters from parsed arguments
# Usage: validate_all_llm_params
# Checks all _arg_* variables that are set
validate_all_llm_params() {
    local param value var_name exit_code=0
    
    for param in temperature top_p max_tokens frequency_penalty presence_penalty seed; do
        var_name="_arg_${param}"
        value="${!var_name:-}"
        if [[ -n "$value" ]]; then
            if ! validate_param "$param" "$value"; then
                log "Invalid value for --${param}: $value" -1
                exit_code=1
            fi
        fi
    done
    
    return $exit_code
}

# One-of validation helper (replaces eval-based validation)
# Usage: validate_one_of <value> <allowed1> <allowed2> ...
validate_one_of() {
    local value="$1"
    shift
    local allowed=("$@")
    
    for item in "${allowed[@]}"; do
        [[ "$item" == "$value" ]] && return 0
    done
    
    return 1
}

# Validate string is safe for YAML (no injection characters)
validate_yaml_safe() {
    local val="$1"
    # Reject strings containing newlines, quotes, or YAML special chars at start
    [[ "$val" =~ $'\n' ]] && return 1
    [[ "$val" =~ ^[\-\:\,\[\]\{\}\*\&\?\|] ]] && return 1
    return 0
}

# Validate string is safe for shell (basic check)
validate_shell_safe() {
    local val="$1"
    # Reject strings with shell metacharacters
    [[ "$val" =~ [\;\&\|\$\(\)\<\>\`\*\?\[\]\{\}] ]] && return 1
    return 0
}
