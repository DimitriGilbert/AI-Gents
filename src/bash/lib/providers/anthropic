#!/bin/bash
#
# Anthropic Provider Plugin for AI-Gents
# https://www.anthropic.com/
#

source "${_SCRIPT_DIR}/lib/providers/_base"

PROVIDER_NAME="anthropic"
PROVIDER_URL="https://api.anthropic.com/v1"
PROVIDER_DEFAULT_MODEL="${AI_ANTHROPIC_MODEL:-claude-3-5-haiku}"
PROVIDER_API_KEY_ENV="AI_ANTHROPIC_API_KEY"

provider_get_url() {
    echo "https://${AI_ANTHROPIC_HOST:-api.anthropic.com}/v1"
}

provider_get_headers() {
    local api_key="$1"
    local -n headers="$2"
    
    headers=(-H "Content-Type: application/json")
    
    if [[ -n "$api_key" ]]; then
        headers+=(-H "x-api-key: ${api_key}")
        headers+=(-H "anthropic-version: 2023-06-01")
    fi
}

provider_build_payload() {
    local model="$1"
    local messages_json="$2"
    local stream="$3"
    shift 3
    
    # Anthropic uses different message format
    local payload
    payload=$(jq -n \
        --arg model "$model" \
        --argjson messages "$messages_json" \
        --argjson stream "$stream" \
        '{model: $model, messages: $messages, stream: $stream, max_tokens: 4096}')
    
    for param in "$@"; do
        if [[ "$param" =~ ^([^=]+)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            
            case "$key" in
                max_tokens)
                    payload=$(echo "$payload" | jq --argjson val "$value" '.max_tokens = $val')
                    ;;
                temperature)
                    payload=$(echo "$payload" | jq --argjson val "$value" '. + {temperature: $val}')
                    ;;
                top_p|top_k)
                    payload=$(echo "$payload" | jq --arg key "$key" --argjson val "$value" '. + {($key): $val}')
                    ;;
            esac
        fi
    done
    
    echo "$payload"
}

provider_parse_stream_chunk() {
    local chunk="$1"
    echo "$chunk" | jq -r '.delta.text // .completion // ""'
}

provider_parse_response() {
    local response="$1"
    echo "$response" | jq -r '.content[0].text // .completion // ""'
}

provider_has_error() {
    local response="$1"
    echo "$response" | jq -e '.error' >/dev/null 2>&1
}

provider_parse_error() {
    local response="$1"
    echo "$response" | jq -r '.error.message // .error.type // empty'
}

# Override: Anthropic supports multimodal content (Claude 3.x+)
provider_supports_multimodal() {
    return 0
}

# Override: Format content for Anthropic API
# Anthropic uses different format: type "image" with source object
provider_format_multimodal_content() {
    local content_json="$1"
    # Convert from OpenAI format to Anthropic format
    # OpenAI: {"type": "image_url", "image_url": {"url": "data:image/jpeg;base64,..."}}
    # Anthropic: {"type": "image", "source": {"type": "base64", "media_type": "image/jpeg", "data": "..."}}
    echo "$content_json" | jq '[.[] | 
        if .type == "image_url" then
            {
                type: "image",
                source: {
                    type: "base64",
                    media_type: (.mime_type // "image/jpeg"),
                    data: (.image_url.url | capture("^data:[^;]+;base64,(?<data>.*)$").data)
                }
            }
        else
            .
        end]'
}

# Override: Get supported content types
provider_get_supported_content_types() {
    # Anthropic supports images (png, jpeg, webp, gif) and PDFs (as images)
    echo "image document"
}

# =============================================================================
# TOOL CALLING INTERFACE
# =============================================================================

# Override: Anthropic Claude supports tool calling
provider_supports_tools() {
    return 0
}

# Override: Format tools for Anthropic API
# Converts standard format to Anthropic format:
# Input:  [{"type": "function", "function": {"name": "...", "description": "...", "parameters": {...}}}]
# Output: [{"name": "...", "description": "...", "input_schema": {...}}]
provider_format_tools() {
    local tools_json="$1"
    # Remove type:function wrapper, rename parameters to input_schema
    echo "$tools_json" | jq '[.[] | .function | {name: .name, description: .description, input_schema: .parameters}]'
}

# Override: Parse tool calls from Anthropic response
# Source: .content[] blocks with type: "tool_use"
# Output: [{"id": "...", "name": "...", "arguments": "..."}]
# Note: arguments is JSON string (Anthropic has "input" as parsed object)
provider_parse_tool_calls() {
    local response="$1"
    # Extract tool_use blocks from content array, convert input object to JSON string
    echo "$response" | jq '[.content[]? | select(.type == "tool_use") | {id: .id, name: .name, arguments: (.input | tojson)}] // empty'
}

# Override: Format tool result for Anthropic conversation history
# Anthropic uses role: "user" with content blocks, not role: "tool"
# Output: {"role": "user", "content": [{"type": "tool_result", "tool_use_id": "...", "content": "..."}]}
provider_format_tool_result() {
    local tool_call_id="$1"
    local tool_name="$2"
    local result="$3"
    # Anthropic uses role: "user" with tool_result content block
    jq -n -c \
        --arg id "$tool_call_id" \
        --arg content "$result" \
        '{role: "user", content: [{type: "tool_result", tool_use_id: $id, content: $content}]}'
}

# Override: Format assistant message from provider response for conversation history
# Usage: provider_format_assistant_message <response_json>
# Returns: Normalized JSON: {role: "assistant", content: "...", tool_calls: [...]}
provider_format_assistant_message() {
    local response="$1"

    # Anthropic response has .content array with different block types
    # - Text content: blocks with type: "text" (combine all)
    # - Tool calls: blocks with type: "tool_use" (convert to standard format)
    echo "$response" | jq -c '
        {
            role: "assistant",
            content: (
                [.content[]? | select(.type == "text") | .text] |
                join("") |
                if length > 0 then . else null end
            ),
            tool_calls: (
                [.content[]? | select(.type == "tool_use") |
                    {
                        id: .id,
                        type: "function",
                        function: {
                            name: .name,
                            arguments: (.input | tojson)
                        }
                    }
                ] |
                if length > 0 then . else null end
            )
        }
    '
}
