#!/bin/bash
#
# OpenAI Provider Plugin for AI-Gents
# https://platform.openai.com/
#

# Source base interface
# shellcheck source=_base
source "${_SCRIPT_DIR}/lib/providers/_base"

# Provider metadata
PROVIDER_NAME="openai"
PROVIDER_URL="https://api.openai.com/v1"
PROVIDER_DEFAULT_MODEL="${AI_OPENAI_MODEL:-gpt-4o-mini}"
PROVIDER_API_KEY_ENV="AI_OPENAI_API_KEY"

# Override: Get API base URL (with custom host support)
provider_get_url() {
    echo "https://${AI_OPENAI_HOST:-api.openai.com}/v1"
}

# Override: Build payload with OpenAI-specific handling
provider_build_payload() {
    local model="$1"
    local messages_json="$2"
    local stream="$3"
    shift 3
    
    # Start with base payload
    local payload
    payload=$(jq -n \
        --arg model "$model" \
        --argjson messages "$messages_json" \
        --argjson stream "$stream" \
        '{model: $model, messages: $messages, stream: $stream}')
    
    # Add extra parameters with OpenAI-specific validation
    for param in "$@"; do
        if [[ "$param" =~ ^([^=]+)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            
            case "$key" in
                temperature)
                    # OpenAI: 0 to 2
                    if (( $(echo "$value >= 0 && $value <= 2" | bc -l) )); then
                        payload=$(echo "$payload" | jq --argjson val "$value" '. + {temperature: $val}')
                    fi
                    ;;
                top_p)
                    # OpenAI: 0 to 1
                    if (( $(echo "$value >= 0 && $value <= 1" | bc -l) )); then
                        payload=$(echo "$payload" | jq --argjson val "$value" '. + {top_p: $val}')
                    fi
                    ;;
                max_tokens)
                    # OpenAI: positive integer
                    if [[ "$value" =~ ^[0-9]+$ ]]; then
                        payload=$(echo "$payload" | jq --argjson val "$value" '. + {max_tokens: $val}')
                    fi
                    ;;
                frequency_penalty|presence_penalty)
                    # OpenAI: -2 to 2
                    if (( $(echo "$value >= -2 && $value <= 2" | bc -l) )); then
                        payload=$(echo "$payload" | jq --arg key "$key" --argjson val "$value" '. + {($key): $val}')
                    fi
                    ;;
                seed)
                    # Integer seed
                    if [[ "$value" =~ ^[0-9]+$ ]]; then
                        payload=$(echo "$payload" | jq --argjson val "$value" '. + {seed: $val}')
                    fi
                    ;;
                response_format|tool_choice)
                    # JSON objects
                    payload=$(echo "$payload" | jq --arg key "$key" --argjson val "$value" '. + {($key): $val}')
                    ;;
                tools)
                    # Tools array
                    payload=$(echo "$payload" | jq --argjson val "$value" '. + {tools: $val}')
                    ;;
                *)
                    # Standard parameters
                    if [[ "$value" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
                        payload=$(echo "$payload" | jq --arg key "$key" --argjson val "$value" '. + {($key): $val}')
                    elif [[ "$value" == "true" || "$value" == "false" ]]; then
                        payload=$(echo "$payload" | jq --arg key "$key" --argjson val "$value" '. + {($key): $val}')
                    else
                        payload=$(echo "$payload" | jq --arg key "$key" --arg val "$value" '. + {($key): $val}')
                    fi
                    ;;
            esac
        fi
    done
    
    echo "$payload"
}

# Override: Parse streaming chunk
provider_parse_stream_chunk() {
    local chunk="$1"
    local content
    
    # Check for error first
    if echo "$chunk" | jq -e '.error' >/dev/null 2>&1; then
        return 1
    fi
    
    # Extract content from delta
    content=$(echo "$chunk" | jq -r '.choices[0].delta.content // ""')
    
    # Handle special characters
    content="${content//\\\"/\"}"
    content="${content//\\n/$'\n'}"
    content="${content//\\t/$'\t'}"
    
    printf '%b' "$content"
}

# Override: OpenAI supports multimodal content (GPT-4o, GPT-4 Vision, etc.)
provider_supports_multimodal() {
    return 0
}

# Override: Format content for OpenAI API
# OpenAI uses standard OpenAI format (already compatible)
provider_format_multimodal_content() {
    local content_json="$1"
    # OpenAI uses standard format: [{"type": "text", "text": "..."}, {"type": "image_url", "image_url": {"url": "..."}}]
    # Just remove any mime_type metadata we added
    echo "$content_json" | jq '[.[] | del(.mime_type)]'
}

# Override: Get supported content types
provider_get_supported_content_types() {
    # OpenAI supports images (png, jpeg, webp, gif) and documents
    echo "image document"
}

# =============================================================================
# TOOL CALLING INTERFACE
# =============================================================================

# Override: Check if provider supports tool calling
provider_supports_tools() {
    # OpenAI fully supports function/tool calling
    return 0
}

# Override: Format tools for OpenAI API request
# OpenAI uses standard format, so just pass through
provider_format_tools() {
    local tools_json="$1"
    echo "$tools_json"
}

# Override: Parse tool calls from OpenAI response
# Input: OpenAI response JSON
# Output: Standardized format [{"id": "...", "name": "...", "arguments": "..."}]
provider_parse_tool_calls() {
    local response="$1"

    # Parse .choices[0].message.tool_calls[] to standardized format
    # Arguments are already JSON strings in OpenAI format
    echo "$response" | jq -r '[
        .choices[0].message.tool_calls[]? |
        {
            id: .id,
            name: .function.name,
            arguments: .function.arguments
        }
    ] // empty'
}

# Override: Format tool result for OpenAI conversation history
provider_format_tool_result() {
    local tool_call_id="$1"
    local tool_name="$2"
    local result="$3"

    # OpenAI format: {"role": "tool", "tool_call_id": "...", "content": "..."}
    # tool_name is not used in OpenAI format (ID is used for matching)
    jq -n -c \
        --arg id "$tool_call_id" \
        --arg content "$result" \
        '{role: "tool", tool_call_id: $id, content: $content}'
}

# Override: Format assistant message from provider response for conversation history
# Usage: provider_format_assistant_message <response_json>
# Returns: Normalized JSON: {role: "assistant", content: "...", tool_calls: [...]}
provider_format_assistant_message() {
    local response="$1"

    # OpenAI response path: .choices[0].message
    # Extract content and tool_calls, normalize to standard format
    echo "$response" | jq -c '
        .choices[0].message |
        {
            role: "assistant",
            content: (.content // null),
            tool_calls: (.tool_calls // null)
        }
    '
}
