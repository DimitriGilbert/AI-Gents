#!/bin/bash
# @parseArger-begin
# @parseArger-help "I send an SOS to the world" --option "help" --short-option "h"
# @parseArger-verbose --option "verbose" --level "0" --quiet-option "quiet"
_has_colors=0
if [ -t 1 ]; then # Check if stdout is a terminal
    ncolors=$(tput colors 2>/dev/null)
    if [ -n "$ncolors" ] && [ "$ncolors" -ge 8 ]; then
        _has_colors=1
    fi
fi
# @parseArger-declarations
# @parseArger pos message "message to the AI"
# @parseArger opt api "api url"
# @parseArger opt api-key "api key"
# @parseArger opt model "model name"
# @parseArger opt system "system prompt"
# @parseArger opt ai-name "AI"
# @parseArger opt username "your name" --default-value "You"
# @parseArger opt log-file "log file for the chat" --default-value "$(date '+%Y-%m-%d-%H-%M-%S.md' )"
# @parseArger opt agent "agent file to load"
# @parseArger opt agent-task "agent specific task to perfrom"
# @parseArger flag log-user "log user input" --on
# @parseArger flag log-ai "log ai output" --on
# @parseArger-declarations-end

# @parseArger-utils
_helpHasBeenPrinted=1
_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
# @parseArger-utils-end

# @parseArger-parsing

__cli_arg_count=$#

die() {
    local _ret=1
    if [[ -n "$2" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
        _ret="$2"
    fi
    test "${_PRINT_HELP:-no}" = yes && print_help >&2
    log "$1" -3 >&2
    exit "${_ret}"
}

begins_with_short_option() {
    local first_option all_short_options=''
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# POSITIONALS ARGUMENTS
_positionals=()
_optional_positionals=()
_arg_message=""
# OPTIONALS ARGUMENTS
_arg_api=
_arg_api_key=
_arg_model=
_arg_system=
_arg_ai_name=
_arg_username="You"
_arg_log_file="$(date '+%Y-%m-%d-%H-%M-%S.md')"
_arg_agent=
_arg_agent_task=
# FLAGS
_arg_log_user="on"
_arg_log_ai="on"
# NESTED
_verbose_level="0"

print_help() {
    _triggerSCHelp=1

    if [[ "$_helpHasBeenPrinted" == "1" ]]; then
        _helpHasBeenPrinted=0
        echo -e "I send an SOS to the world:"
        echo -e "	message: message to the AI"
        echo -e "	--api <api>: api url"
        echo -e "	--api-key <api-key>: api key"
        echo -e "	--model <model>: model name"
        echo -e "	--system <system>: system prompt"
        echo -e "	--ai-name <ai-name>: AI"
        echo -e "	--username <username>: your name [default: ' You ']"
        echo -e "	--log-file <log-file>: log file for the chat [default: ' $(date '+%Y-%m-%d-%H-%M-%S.md') ']"
        echo -e "	--agent <agent>: agent file to load"
        echo -e "	--agent-task <agent-task>: agent specific task to perfrom"
        echo -e "	--log-user|--no-log-user: log user input, on by default (use --no-log-user to turn it off)"
        echo -e "	--log-ai|--no-log-ai: log ai output, on by default (use --no-log-ai to turn it off)"
        echo -e "Usage :
	$0 <message> [--api <value>] [--api-key <value>] [--model <value>] [--system <value>] [--ai-name <value>] [--username <value>] [--log-file <value>] [--agent <value>] [--agent-task <value>] [--[no-]log-user] [--[no-]log-ai]"
    fi

}

log() {
    local _arg_msg="${1}"
    local _arg_level="${2:-0}"
    if [ "${_arg_level}" -le "${_verbose_level}" ]; then
        case "$_arg_level" in
        -3)
            _arg_COLOR="\033[0;31m"
            ;;
        -2)
            _arg_COLOR="\033[0;33m"
            ;;
        -1)
            _arg_COLOR="\033[1;33m"
            ;;
        1)
            _arg_COLOR="\033[0;32m"
            ;;
        2)
            _arg_COLOR="\033[1;36m"
            ;;
        3)
            _arg_COLOR="\033[0;36m"
            ;;
        *)
            _arg_COLOR="\033[0m"
            ;;
        esac
        if [ "${_has_colors}" == "1" ]; then
            echo -e "${_arg_COLOR}${_arg_msg}\033[0m"
        else
            echo "${_arg_msg}"
        fi
    fi
}

parse_commandline() {
    _positionals_count=0
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --api)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_api="$2"
            shift
            ;;
        --api=*)
            _arg_api="${_key##--api=}"
            ;;

        --api-key)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_api_key="$2"
            shift
            ;;
        --api-key=*)
            _arg_api_key="${_key##--api-key=}"
            ;;

        --model)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_model="$2"
            shift
            ;;
        --model=*)
            _arg_model="${_key##--model=}"
            ;;

        --system)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_system="$2"
            shift
            ;;
        --system=*)
            _arg_system="${_key##--system=}"
            ;;

        --ai-name)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_ai_name="$2"
            shift
            ;;
        --ai-name=*)
            _arg_ai_name="${_key##--ai-name=}"
            ;;

        --username)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_username="$2"
            shift
            ;;
        --username=*)
            _arg_username="${_key##--username=}"
            ;;

        --log-file)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_log_file="$2"
            shift
            ;;
        --log-file=*)
            _arg_log_file="${_key##--log-file=}"
            ;;

        --agent)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_agent="$2"
            shift
            ;;
        --agent=*)
            _arg_agent="${_key##--agent=}"
            ;;

        --agent-task)
            test $# -lt 2 && die "Missing value for the option: '$_key'" 1
            _arg_agent_task="$2"
            shift
            ;;
        --agent-task=*)
            _arg_agent_task="${_key##--agent-task=}"
            ;;

        --log-user)
            _arg_log_user="on"
            ;;
        --no-log-user)
            _arg_log_user="off"
            ;;
        --log-ai)
            _arg_log_ai="on"
            ;;
        --no-log-ai)
            _arg_log_ai="off"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        --verbose)
            if [ $# -lt 2 ]; then
                _verbose_level="$((_verbose_level + 1))"
            else
                _verbose_level="$2"
                shift
            fi
            ;;
        --quiet)
            if [ $# -lt 2 ]; then
                _verbose_level="$((_verbose_level - 1))"
            else
                _verbose_level="-$2"
                shift
            fi
            ;;

        *)
            _last_positional="$1"
            _positionals+=("$_last_positional")
            _positionals_count=$((_positionals_count + 1))
            ;;
        esac
        shift
    done
}

handle_passed_args_count() {
    local _required_args_string="message"
    if [ "${_positionals_count}" -gt 1 ] && [ "$_helpHasBeenPrinted" == "1" ]; then
        _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\n\t${_positionals[*]}" 1
    fi
    if [ "${_positionals_count}" -lt 1 ] && [ "$_helpHasBeenPrinted" == "1" ]; then
        _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.
	${_positionals[*]}" 1
    fi
}

assign_positional_args() {
    local _positional_name _shift_for=$1
    _positional_names="_arg_message "
    shift "$_shift_for"
    for _positional_name in ${_positional_names}; do
        test $# -gt 0 || break
        eval "if [ \"\$_one_of${_positional_name}\" != \"\" ];then [[ \"\${_one_of${_positional_name}[*]}\" =~ \"\${1}\" ]];fi" || die "${_positional_name} must be one of: $(eval "echo \"\${_one_of${_positional_name}[*]}\"")" 1
        eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an ParseArger bug." 1
        shift
    done
}

print_debug() {
    print_help
    # shellcheck disable=SC2145
    echo "DEBUG: $0 $@"

    echo -e "	message: ${_arg_message}"
    echo -e "	api: ${_arg_api}"
    echo -e "	api-key: ${_arg_api_key}"
    echo -e "	model: ${_arg_model}"
    echo -e "	system: ${_arg_system}"
    echo -e "	ai-name: ${_arg_ai_name}"
    echo -e "	username: ${_arg_username}"
    echo -e "	log-file: ${_arg_log_file}"
    echo -e "	agent: ${_arg_agent}"
    echo -e "	agent-task: ${_arg_agent_task}"
    echo -e "	log-user: ${_arg_log_user}"
    echo -e "	log-ai: ${_arg_log_ai}"

}

on_interrupt() {
    die Process aborted! 130
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"
trap on_interrupt INT

# @parseArger-parsing-end
# print_debug "$@"
# @parseArger-end

_AGENT_CONFIG=""
# Function to load agent configuration
load_agent_config() {
    local agent_file="$1"
    if [[ ! -f "$agent_file" ]]; then
        die "Agent file not found: $agent_file" 1
    fi
    _AGENT_CONFIG="$(cat "$agent_file")"

    # Check if yq is installed
    if ! command -v yq &>/dev/null; then
        die "yq is required to parse YAML files. Please install it first." 1
    fi

    # Load configuration
    _arg_model=$(echo "$_AGENT_CONFIG" | yq '.model.name')
    _arg_system=$(echo "$_AGENT_CONFIG" | yq '.system.prompt')
    _arg_ai_name=$(echo "$_AGENT_CONFIG" | yq '.name')

    # Set API based on provider if not explicitly set
    if [[ -z "$_arg_api" ]]; then
        local provider=$(yq '.model.provider' "$agent_file")
        case "$provider" in
        "openai")
            _arg_api="https://api.openai.com/v1/chat/completions"
            ;;
        "lmstudio")
            _arg_api="http://localhost:1234/v1/chat/completions"
            ;;
        *)
            die "Unsupported provider: $provider" 1
            ;;
        esac
    fi

    # Load memory window setting
    local memory_window=$(yq '.settings.memory_window' "$agent_file")
    if [[ "$memory_window" != "null" ]]; then
        export MEMORY_WINDOW="$memory_window"
    fi

    # Store system prompt from agent config
    SYSTEM_PROMPT=$(yq '.system.prompt' "$agent_file")
    if [ "$SYSTEM_PROMPT" != "" ]; then
        _arg_system+="\n$SYSTEM_PROMPT"
    fi
    if [ "$_arg_agent_task" != "" ]; then
        _arg_system+="\n$_arg_agent_task"
    fi
}

# Configuration
API_KEY="${_arg_api_key}" # Replace with your actual API key

# Load agent configuration if specified
if [[ -n "$_arg_agent" ]]; then
    load_agent_config "$_arg_agent"
fi

# Set default API URL if not set
if [[ ! "$_arg_api" =~ ^https?:// ]] && [[ ! "$_arg_api" =~ ^http:// ]]; then
    _arg_api="http://$_arg_api"
fi

# Initialize conversation history and system prompt
CONVERSATION_HISTORY=()
SYSTEM_PROMPT=""
last_message=""

# Function to log messages to the file
log_to_file() {
    local role="$1"
    local content="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Create directory if it doesn't exist
    mkdir -p "$(dirname "$_arg_log_file")"

    # Append message to log file in markdown format
    echo -e "\n### $role ($timestamp)\n\n$content\n" >>"$_arg_log_file"
}

# Function to escape JSON string
escape_json() {
    local str="$1"
    str="${str//\\/\\\\}"     # escape backslashes
    str="${str//\"/\\\"}"     # escape quotes
    str="${str//[$'\t']/\\t}" # escape tabs
    str="${str//[$'\n']/\\n}" # escape newlines
    str="${str//[$'\r']/\\r}" # escape carriage returns
    echo "$str"
}

# Function to send a message to the LLM API and stream the response
send_message() {
    local user_message="$1"
    local system_message="$2"
    local tmp_response=$(mktemp)
    local tmp_payload=$(mktemp)

    # Escape messages
    user_message=$(escape_json "$user_message")
    system_message=$(escape_json "$system_message")

    # Build messages array directly in JSON
    local messages="["

    # Add system message if provided
    if [[ -n "$system_message" ]]; then
        messages+="{\"role\":\"system\",\"content\":\"$system_message\"}"
    fi

    # Add conversation history
    for msg in "${CONVERSATION_HISTORY[@]}"; do
        [[ -n "$messages" && "$messages" != "[" ]] && messages+=","
        messages+="$msg"
    done

    # Add current user message
    [[ -n "$messages" && "$messages" != "[" ]] && messages+=","
    messages+="{\"role\":\"user\",\"content\":\"$user_message\"}"
    messages+="]"

    # Create the complete payload
    echo "{\"model\":\"$_arg_model\",\"messages\":$messages,\"stream\":true}" >"$tmp_payload"

    # Debug output
    echo "DEBUG Payload:" >/tmp/debug_raw
    cat "$tmp_payload" >>/tmp/debug_raw

    # Send the request and stream response
    local curl_cmd=(curl -N -s -X POST "$_arg_api"
        -H "Content-Type: application/json"
        -d @"$tmp_payload")
    if [[ -n "$API_KEY" ]]; then
        curl_cmd+=(-H "Authorization: Bearer $API_KEY")
    fi

    echo # Add initial newline for spacing
    "${curl_cmd[@]}" | while IFS= read -r line; do
        if [[ $line == data:* ]]; then
            content=$(echo "$line" | sed 's/^data: //g' | grep -o '"content":"[^"]*"' | sed 's/"content":"//;s/"$//')
            if [[ -n "$content" ]]; then
                printf '%b' "$content"
                printf '%b' "$content" >>"$tmp_response"
            fi
        fi
    done
    echo

    # Get the full response and update conversation history
    full_response=$(<"$tmp_response")
    if [[ "$full_response" != "" ]]; then
        # Escape both messages before adding to history
        escaped_user_message=$(escape_json "$user_message")
        escaped_response=$(escape_json "$full_response")

        # Add both messages to history with proper escaping
        CONVERSATION_HISTORY+=("{\"role\":\"user\",\"content\":\"$escaped_user_message\"}")
        CONVERSATION_HISTORY+=("{\"role\":\"assistant\",\"content\":\"$escaped_response\"}")

        # Log AI response if enabled
        if [[ "$_arg_log_ai" == "on" ]]; then
            log_to_file "$_arg_ai_name" "$full_response"
        fi

        # Trim history if memory window is set
        if [[ -n "$MEMORY_WINDOW" ]]; then
            local window_size=$((MEMORY_WINDOW * 2))
            if [[ ${#CONVERSATION_HISTORY[@]} -gt $window_size ]]; then
                CONVERSATION_HISTORY=("${CONVERSATION_HISTORY[@]: -$window_size}")
            fi
        fi
    fi

    export last_message="$(cat "$tmp_response")";
    rm -f "$tmp_response" "$tmp_payload"
}

# Function to parse tool calls from the message
parse_tool_calls() {
    local message="$1"
    # Look for tool calls in the format: {"tool_calls":[{"type":"function","function":{"name":"...","arguments":{...}}}]}
    if [[ "$message" =~ \{\"tool_calls\"\:\[ ]]; then
        # Extract and process tool calls
        echo "$message" | jq -r '.tool_calls[] | select(.type=="function") | .function'
    fi
}

# Function to execute tools
execute_agent_tool() {
    local tool_name="$1"
    local arguments="$2"
    # Check if command exists and execute
    if command -v "${tool_name}" >/dev/null 2>&1; then
        # Build the command array
        local cmd=()
        
        # Parse JSON arguments and add them to command array
        while IFS="=" read -r key value; do
            if [[ -n "$key" ]]; then
                cmd+=("--${key}" "${value}")
            fi
        done < <(echo "$arguments" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"')
        "${cmd[@]}";
        return $?
    else
        log "Error: Tool '${tool_name}' not found" -1
        return 1
    fi
}

# Main loop for user interaction
echo "Welcome to the LLM Chat! Type '/bye' to quit."
if [[ "$_arg_message" != "" ]]; then
    if [[ "$_arg_log_user" == "on" ]]; then
        log_to_file "$_arg_username" "$_arg_message"
    fi
    echo -n "$_arg_ai_name: "
    # Store system prompt if provided via command line
    if [[ -n "$_arg_system" ]]; then
        SYSTEM_PROMPT="$_arg_system"
    fi
    send_message "$_arg_message" "$SYSTEM_PROMPT"
fi

while true; do
    echo
    user_input=$(rlwrap -S "$_arg_username: " bash -c 'read -r line; echo $line')
    if [[ "$user_input" == "/bye" ]]; then
        echo "Goodbye!"
        break
    elif [[ "$user_input" =~ ^/task ]] && [ "$_AGENT_CONFIG" != "" ]; then
        task_name=$(echo "$user_input" | cut -d' ' -f2-)
        task=$(echo "$_AGENT_CONFIG" | yq ".tasks.$task_name")
        if [ "$task" = "" ]; then
            echo "Task not found: $task_name"
        else
            task_prompt=$(echo "$task" | yq ".prompt")
            message_after_task=$(echo "$user_input" | cut -d' ' -f3-)
            if [ "$message_after_task" != "" ]; then
                task_prompt+=$message_after_task
            fi
            send_message "$task_prompt" "$SYSTEM_PROMPT"
        fi
        continue
    fi
    if [[ "$_arg_log_user" == "on" ]]; then
        log_to_file "$_arg_username" "$user_input"
    fi
    echo -n "$_arg_ai_name: "
    send_message "$user_input" "$SYSTEM_PROMPT"
    
    # Check for tool calls in the last message
    if [[ "$last_message" != "" ]]; then
        tool_calls=$(parse_tool_calls "$last_message")
        if [[ "$tool_calls" != "" ]]; then
            while IFS= read -r tool_call; do
                tool_name=$(echo "$tool_call" | jq -r '.name')
                tool_args=$(echo "$tool_call" | jq -r '.arguments')
                tool_result=$(execute_agent_tool "$tool_name" "$tool_args")
                
                # Send tool result back to the conversation
                # send_message "Tool '$tool_name' result: $tool_result" "$SYSTEM_PROMPT"
            done <<< "$tool_calls"
        fi
    fi

done
